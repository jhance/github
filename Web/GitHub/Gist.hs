{-# LANGUAGE FlexibleContexts, OverloadedStrings #-}
-- | An API for creating and fetching Gists from GitHub. Most of the functions
-- here have very generic types over monad typeclasses; it may be helpful to
-- note that for the most part either 'ResourceT' 'IO' or 'IO' will fit
-- depending on if the resulting monad needs to be a 'MonadResource' or not,
-- respectively.
module Web.GitHub.Gist
    (
    -- * Core Data Types
    Gist(..),
    GistUser(..),
    GistCreate(..),
    GistEdit(..),

    -- * ID-Based Retrieval
    getGist,

    -- * User Gists
    gists,
    getGists,

    -- * Public Gists
    publicGists,
    getPublicGists,
    
    -- * Write Access
    createGist
    )
where

import Control.Applicative
import Control.Failure
import Control.Monad
import Control.Monad.IO.Class
import Control.Monad.Trans.Control
import Control.Monad.Trans.Resource
import Data.Aeson
import Data.Conduit
import qualified Data.Conduit.List as CL
import qualified Data.Map as M
import qualified Data.Text as T
import Network.HTTP.Conduit

import Web.GitHub.Internal.Request

-- | Represents a complete Gist as obtained from the JSON sent back by a
-- HTTPS request. This should rarely if ever be created without a HTTPS
-- request, since the information is likely to be invalid.
data Gist = Gist {
    gistUrl :: T.Text,
    gistId :: Integer,
    gistDescription :: Maybe T.Text,
    gistUser :: Maybe GistUser,
    gistCommentCount :: Int,
    gistHtmlUrl :: T.Text,
    gistPullUrl :: T.Text,
    gistPushUrl :: T.Text,
    gistCreatedAt :: T.Text,
    gistFiles :: M.Map T.Text GistFile
    }
    deriving (Show, Read, Eq)

-- | Represents a User from the result of a Gist query. This doesn't contain
-- all of the same data as a normal User, so to convert another HTTPS query
-- must be made to GitHub to get more detail about the User.
data GistUser = GistUser {
    gistUserLogin :: T.Text,
    gistUserId :: Integer,
    gistUserAvatarUrl :: T.Text,
    gistUserGravatarId :: T.Text,
    gistUserUrl :: T.Text
    }
    deriving (Show, Read, Eq)

-- | Represents a file stored in a 'Gist' that has already been saved on the
-- server. This data is generated by the server when the 'Gist' is created
-- and should not generally be created by hand.
--
-- If the content is not specified within the JSON, then it becomes Nothing.
-- This does not signify an empty file; rather, the file must be obtained using
-- an HTTP query on 'gistFileUrl'.
data GistFile = GistFile {
    gistFileContent :: Maybe T.Text,
    gistFileLanguage :: Maybe T.Text,
    gistFileName :: T.Text,
    gistFileSize :: Integer,
    gistFileUrl :: T.Text
    }
    deriving (Show, Read, Eq)

-- | Represents a 'Gist' ready for creation. As such, data to be generated by
-- the GitHub server is not included in this data structure.
data GistCreate = GistCreate {
    gistCreateDescription :: Maybe T.Text,
    gistCreatePublic :: Bool,
    gistCreateFiles :: M.Map T.Text T.Text
    }
    deriving (Show, Read, Eq)

-- | Represents an update to a 'Gist'. Fields with value of Nothing will not
-- be updated; every field is optional.
data GistEdit = GistEdit {
    gistEditDescription :: Maybe T.Text,
    gistEditFiles :: Maybe (M.Map T.Text (Maybe T.Text, Maybe T.Text)) -- ^ A map of the form old name to (contents, new name)
    }
    deriving (Show, Read, Eq)

instance FromJSON Gist where
    parseJSON (Object o) = Gist
        <$> o .: "url"
        <*> liftM read (o .: "id")
        <*> o .:? "description"
        <*> o .:? "user"
        <*> o .: "comments"
        <*> o .: "html_url"
        <*> o .: "git_pull_url"
        <*> o .: "git_push_url"
        <*> o .: "created_at"
        <*> o .: "files"

    parseJSON _ = mzero

instance FromJSON GistUser where
    parseJSON (Object o) = GistUser
        <$> o .: "login"
        <*> o .: "id"
        <*> o .: "avatar_url"
        <*> o .: "gravatar_id"
        <*> o .: "url"

    parseJSON _ = mzero

instance FromJSON GistFile where
    parseJSON (Object o) = GistFile
        <$> o .:? "content"
        <*> o .:? "language"
        <*> o .: "filename"
        <*> o .: "size"
        <*> o .: "raw_url"

    parseJSON _ = mzero

instance ToJSON GistCreate where
    toJSON (GistCreate desc pub files) = object $ descPair ++ publicPair ++ filesPair
        where descPair = case desc of 
                            Nothing -> []
                            Just desc' -> ["description" .= desc']
              publicPair = ["public" .= pub]
              filesPair = ["files" .= filesObj]

              filesObj = object $ M.foldrWithKey f [] files
              f filename content acc = [filename .= object ["content" .= content]] ++ acc

instance ToJSON GistEdit where
    toJSON (GistEdit desc files) = object $ descPair ++ filesPair
        where descPair = case desc of
                Nothing -> []
                Just desc' -> ["description" .= desc']
              filesPair = case files of
                Nothing -> []
                Just files' -> ["files" .= object (M.foldrWithKey f [] files')]
              f filename (content, newname) acc = contentPair ++ newnamePair ++ acc
                where contentPair = case content of
                        Nothing -> []
                        Just content' -> ["content" .= content']
                      newnamePair = case newname of
                        Nothing -> []
                        Just newname' -> ["filename" .= newname']

jsonToGist :: Value -> Gist
jsonToGist val = case fromJSON val of
                    Success gist -> gist
                    Error err -> error err

-- | Gets a gist by ID.
getGist :: (Failure HttpException m, MonadBaseControl IO m, MonadIO m,
            MonadThrow m, MonadUnsafeIO m)
        => Integer 
        -> Manager
        -> m Gist
getGist id m = runResourceT $ do
    req <- parseUrl $ "https://api.github.com/gists/" ++ show id
    (val, headers) <- simpleRequest req m
    return $ jsonToGist val

-- | Gets a list of all Gists of a user.
-- 
-- As long as there is a next rel, it will continue to fetch more gists. For
-- more efficiency, use `gists`.
--
-- This is a small wrapper around the `gists` function.
getGists :: (Failure HttpException m, MonadBaseControl IO m, MonadIO m,
             MonadThrow m, MonadUnsafeIO m)
         => String
         -> Manager
         -> m [Gist]
getGists user m = runResourceT $ gists user m $$ CL.consume

-- | Source that obtains all gists of a user with the specified username. If
-- the user is logged in, then it is able to grab all gists; otherwise only
-- public gists will be fetched. This is equivalent to
-- `https://api.github.com/users/:user/gists'
gists :: (Failure HttpException m, MonadBaseControl IO m, MonadResource m)
      => String
      -> Manager
      -> Source m Gist
gists user m = let url = "https://api.github.com/users/" ++ user ++ "/gists"
               in pagedRequest url m $= CL.map jsonToGist

-- | Source that obtains all public gists from all users. This is equivalent
-- to `GET https://api.github.com/gists/public` or, if the user is not
-- authenticated, `GET https://api.github.com/gists`, although this behavior
-- is not relied upon.
publicGists :: (Failure HttpException m, MonadBaseControl IO m, MonadResource m)
            => Manager
            -> Source m Gist
publicGists m = let url = "https://api.github.com/gists/public"
                in pagedRequest url m $= CL.map jsonToGist

-- | Creates a new 'Gist' based on the information from a 'GistCreate'. The new
-- 'Gist' is created by a request and sent back in JSON and parsed. This
-- essentially converts a 'GistCreate' template into a real 'Gist' with all of
-- its associated information.
-- 
-- Equivalent to `POST https://api.github.com/gists`.
createGist :: (Failure HttpException m, MonadBaseControl IO m, MonadIO m,
               MonadThrow m, MonadUnsafeIO m)
           => GistCreate
           -> Manager
           -> m Gist
createGist gc m = runResourceT $ do
    let json = encode gc
    req <- parseUrl "https://api.github.com/gists"
    let req' = req { method = "POST", requestBody = RequestBodyLBS json }
    (val, headers) <- simpleRequest req' m
    return $ jsonToGist val

-- | Edits a 'Gist' with the given id based on the fields available in a
-- 'GistEdit'.
--
-- Equivalent to `PATCH https://api.github.com/gists/:id`
editGist :: (Failure HttpException m, MonadBaseControl IO m, MonadIO m,
             MonadThrow m, MonadUnsafeIO m)
         => Integer
         -> GistEdit
         -> Manager
         -> m Gist
editGist id ge m = runResourceT $ do
    let json = encode ge
    req <- parseUrl $ "https://api.github.com/gists/" ++ show id
    let req' = req { method = "PATCH", requestBody = RequestBodyLBS json }
    (val, headers) <- simpleRequest req' m
    return $ jsonToGist val
